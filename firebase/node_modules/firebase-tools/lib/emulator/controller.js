"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const clc = require("cli-color");
const fs = require("fs");
const path = require("path");
const tcpport = require("tcp-port-used");
const pf = require("portfinder");
const logger = require("../logger");
const track = require("../track");
const utils = require("../utils");
const registry_1 = require("../emulator/registry");
const types_1 = require("../emulator/types");
const constants_1 = require("../emulator/constants");
const functionsEmulator_1 = require("../emulator/functionsEmulator");
const databaseEmulator_1 = require("../emulator/databaseEmulator");
const firestoreEmulator_1 = require("../emulator/firestoreEmulator");
const hostingEmulator_1 = require("../emulator/hostingEmulator");
const error_1 = require("../error");
const getProjectId = require("../getProjectId");
const pubsubEmulator_1 = require("./pubsubEmulator");
const commandUtils = require("./commandUtils");
const hub_1 = require("./hub");
const hubExport_1 = require("./hubExport");
const ui_1 = require("./ui");
const loggingEmulator_1 = require("./loggingEmulator");
const dbRulesConfig = require("../database/rulesConfig");
const emulatorLogger_1 = require("./emulatorLogger");
function checkPortOpen(port, host) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const inUse = yield tcpport.check(port, host);
            return !inUse;
        }
        catch (e) {
            logger.debug(`port check error: ${e}`);
            return false;
        }
    });
}
exports.checkPortOpen = checkPortOpen;
function waitForPortClosed(port, host) {
    return __awaiter(this, void 0, void 0, function* () {
        const interval = 250;
        const timeout = 30000;
        try {
            yield tcpport.waitUntilUsedOnHost(port, host, interval, timeout);
        }
        catch (e) {
            throw new error_1.FirebaseError(`TIMEOUT: Port ${port} on ${host} was not active within ${timeout}ms`);
        }
    });
}
exports.waitForPortClosed = waitForPortClosed;
function getAndCheckAddress(emulator, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const host = constants_1.Constants.normalizeHost(options.config.get(constants_1.Constants.getHostKey(emulator), constants_1.Constants.getDefaultHost(emulator)));
        const portVal = options.config.get(constants_1.Constants.getPortKey(emulator), undefined);
        let port;
        let findAvailablePort = false;
        if (portVal) {
            port = parseInt(portVal, 10);
        }
        else {
            port = constants_1.Constants.getDefaultPort(emulator);
            findAvailablePort = constants_1.FIND_AVAILBLE_PORT_BY_DEFAULT[emulator];
        }
        const logger = emulatorLogger_1.EmulatorLogger.forEmulator(emulator);
        const portOpen = yield checkPortOpen(port, host);
        if (!portOpen) {
            if (findAvailablePort) {
                const newPort = yield pf.getPortPromise({ host, port });
                if (newPort != port) {
                    logger.logLabeled("WARN", emulator, `${constants_1.Constants.description(emulator)} unable to start on port ${port}, starting on ${newPort} instead.`);
                    port = newPort;
                }
            }
            else {
                yield cleanShutdown();
                const description = constants_1.Constants.description(emulator);
                logger.logLabeled("WARN", emulator, `Port ${port} is not open on ${host}, could not start ${description}.`);
                logger.logLabeled("WARN", emulator, `To select a different host/port, specify that host/port in a firebase.json config file:
      {
        // ...
        "emulators": {
          "${emulator}": {
            "host": "${clc.yellow("HOST")}",
            "port": "${clc.yellow("PORT")}"
          }
        }
      }`);
                return utils.reject(`Could not start ${description}, port taken.`, {});
            }
        }
        return { host, port };
    });
}
function startEmulator(instance) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = instance.getName();
        track("emulators:start", name);
        yield registry_1.EmulatorRegistry.start(instance);
    });
}
exports.startEmulator = startEmulator;
function cleanShutdown() {
    return __awaiter(this, void 0, void 0, function* () {
        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HUB).logLabeled("BULLET", "emulators", "Shutting down emulators.");
        for (const name of registry_1.EmulatorRegistry.listRunning()) {
            emulatorLogger_1.EmulatorLogger.forEmulator(name).logLabeled("BULLET", name, `Stopping ${constants_1.Constants.description(name)}`);
            yield registry_1.EmulatorRegistry.stop(name);
        }
    });
}
exports.cleanShutdown = cleanShutdown;
function filterEmulatorTargets(options) {
    let targets = types_1.ALL_SERVICE_EMULATORS.filter((e) => {
        return options.config.has(e) || options.config.has(`emulators.${e}`);
    });
    if (options.only) {
        targets = _.intersection(targets, options.only.split(","));
    }
    return targets;
}
exports.filterEmulatorTargets = filterEmulatorTargets;
function shouldStart(options, name) {
    if (name === types_1.Emulators.HUB) {
        return !!options.project;
    }
    const targets = filterEmulatorTargets(options);
    const emulatorInTargets = targets.indexOf(name) >= 0;
    if (name === types_1.Emulators.UI) {
        if (options.config.get("emulators.ui.enabled") === false) {
            return false;
        }
        return (!!options.project && targets.some((target) => types_1.EMULATORS_SUPPORTED_BY_UI.indexOf(target) >= 0));
    }
    if (name === types_1.Emulators.FUNCTIONS &&
        emulatorInTargets &&
        !options.config.get("functions.source")) {
        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).logLabeled("WARN", "functions", `The functions emulator is configured but there is no functions source directory. Have you run ${clc.bold("firebase init functions")}?`);
        return false;
    }
    if (name === types_1.Emulators.HOSTING && emulatorInTargets && !options.config.get("hosting")) {
        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HOSTING).logLabeled("WARN", "hosting", `The hosting emulator is configured but there is no hosting configuration. Have you run ${clc.bold("firebase init hosting")}?`);
        return false;
    }
    return emulatorInTargets;
}
exports.shouldStart = shouldStart;
function startAll(options, noUi = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const targets = filterEmulatorTargets(options);
        options.targets = targets;
        const projectId = getProjectId(options, true);
        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.HUB).logLabeled("BULLET", "emulators", `Starting emulators: ${targets.join(", ")}`);
        if (options.only) {
            const requested = options.only.split(",");
            const ignored = _.difference(requested, targets);
            for (const name of ignored) {
                emulatorLogger_1.EmulatorLogger.forEmulator(name).logLabeled("WARN", name, `Not starting the ${clc.bold(name)} emulator, make sure you have run ${clc.bold("firebase init")}.`);
            }
        }
        if (shouldStart(options, types_1.Emulators.HUB)) {
            const hubAddr = yield getAndCheckAddress(types_1.Emulators.HUB, options);
            const hub = new hub_1.EmulatorHub(Object.assign({ projectId }, hubAddr));
            yield startEmulator(hub);
        }
        let exportMetadata = {
            version: "unknown",
        };
        if (options.import) {
            const importDir = path.resolve(options.import);
            exportMetadata = JSON.parse(fs.readFileSync(path.join(importDir, hubExport_1.HubExport.METADATA_FILE_NAME), "utf8").toString());
        }
        if (shouldStart(options, types_1.Emulators.FUNCTIONS)) {
            const functionsAddr = yield getAndCheckAddress(types_1.Emulators.FUNCTIONS, options);
            const projectId = getProjectId(options, false);
            const functionsDir = path.join(options.extensionDir || options.config.projectDir, options.config.get("functions.source"));
            let inspectFunctions;
            if (options.inspectFunctions) {
                inspectFunctions = commandUtils.parseInspectionPort(options);
                emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FUNCTIONS).logLabeled("WARN", "functions", `You are running the functions emulator in debug mode (port=${inspectFunctions}). This means that functions will execute in sequence rather than in parallel.`);
            }
            const functionsEmulator = new functionsEmulator_1.FunctionsEmulator({
                projectId,
                functionsDir,
                host: functionsAddr.host,
                port: functionsAddr.port,
                debugPort: inspectFunctions,
                env: options.extensionEnv,
                predefinedTriggers: options.extensionTriggers,
                nodeMajorVersion: options.extensionNodeVersion,
            });
            yield startEmulator(functionsEmulator);
        }
        if (shouldStart(options, types_1.Emulators.FIRESTORE)) {
            const firestoreLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.FIRESTORE);
            const firestoreAddr = yield getAndCheckAddress(types_1.Emulators.FIRESTORE, options);
            const args = {
                host: firestoreAddr.host,
                port: firestoreAddr.port,
                projectId,
                auto_download: true,
            };
            if (exportMetadata.firestore) {
                const importDirAbsPath = path.resolve(options.import);
                const exportMetadataFilePath = path.join(importDirAbsPath, exportMetadata.firestore.metadata_file);
                firestoreLogger.logLabeled("BULLET", "firestore", `Importing data from ${exportMetadataFilePath}`);
                args.seed_from_export = exportMetadataFilePath;
            }
            const rulesLocalPath = options.config.get("firestore.rules");
            let rulesFileFound = false;
            if (rulesLocalPath) {
                const rules = path.join(options.projectRoot, rulesLocalPath);
                rulesFileFound = fs.existsSync(rules);
                if (rulesFileFound) {
                    args.rules = rules;
                }
                else {
                    firestoreLogger.logLabeled("WARN", "firestore", `Cloud Firestore rules file ${clc.bold(rules)} specified in firebase.json does not exist.`);
                }
            }
            else {
                firestoreLogger.logLabeled("WARN", "firestore", "Did not find a Cloud Firestore rules file specified in a firebase.json config file.");
            }
            if (!rulesFileFound) {
                firestoreLogger.logLabeled("WARN", "firestore", "The emulator will default to allowing all reads and writes. Learn more about this option: https://firebase.google.com/docs/emulator-suite/install_and_configure#security_rules_configuration.");
            }
            const firestoreEmulator = new firestoreEmulator_1.FirestoreEmulator(args);
            yield startEmulator(firestoreEmulator);
        }
        if (shouldStart(options, types_1.Emulators.DATABASE)) {
            const databaseLogger = emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.DATABASE);
            const databaseAddr = yield getAndCheckAddress(types_1.Emulators.DATABASE, options);
            const args = {
                host: databaseAddr.host,
                port: databaseAddr.port,
                projectId,
                auto_download: true,
            };
            const rc = dbRulesConfig.getRulesConfig(projectId, options);
            logger.debug("database rules config: ", JSON.stringify(rc));
            args.rules = rc;
            if (rc.length === 0) {
                databaseLogger.logLabeled("WARN", "database", "Did not find a Realtime Database rules file specified in a firebase.json config file. The emulator will default to allowing all reads and writes. Learn more about this option: https://firebase.google.com/docs/emulator-suite/install_and_configure#security_rules_configuration.");
            }
            else {
                for (const c of rc) {
                    const rules = path.join(options.projectRoot, c.rules);
                    if (!fs.existsSync(rules)) {
                        databaseLogger.logLabeled("WARN", "database", `Realtime Database rules file ${clc.bold(rules)} specified in firebase.json does not exist.`);
                    }
                }
            }
            const databaseEmulator = new databaseEmulator_1.DatabaseEmulator(args);
            yield startEmulator(databaseEmulator);
        }
        if (shouldStart(options, types_1.Emulators.HOSTING)) {
            const hostingAddr = yield getAndCheckAddress(types_1.Emulators.HOSTING, options);
            const hostingEmulator = new hostingEmulator_1.HostingEmulator({
                host: hostingAddr.host,
                port: hostingAddr.port,
                options,
            });
            yield startEmulator(hostingEmulator);
        }
        if (shouldStart(options, types_1.Emulators.PUBSUB)) {
            if (!projectId) {
                throw new error_1.FirebaseError("Cannot start the Pub/Sub emulator without a project: run 'firebase init' or provide the --project flag");
            }
            const pubsubAddr = yield getAndCheckAddress(types_1.Emulators.PUBSUB, options);
            const pubsubEmulator = new pubsubEmulator_1.PubsubEmulator({
                host: pubsubAddr.host,
                port: pubsubAddr.port,
                projectId,
                auto_download: true,
            });
            yield startEmulator(pubsubEmulator);
        }
        if (!noUi && shouldStart(options, types_1.Emulators.UI)) {
            const loggingAddr = yield getAndCheckAddress(types_1.Emulators.LOGGING, options);
            const loggingEmulator = new loggingEmulator_1.LoggingEmulator({
                host: loggingAddr.host,
                port: loggingAddr.port,
            });
            yield startEmulator(loggingEmulator);
            const uiAddr = yield getAndCheckAddress(types_1.Emulators.UI, options);
            const ui = new ui_1.EmulatorUI(Object.assign({ projectId, auto_download: true }, uiAddr));
            yield startEmulator(ui);
        }
        const running = registry_1.EmulatorRegistry.listRunning();
        for (const name of running) {
            const instance = registry_1.EmulatorRegistry.get(name);
            if (instance) {
                yield instance.connect();
            }
        }
    });
}
exports.startAll = startAll;
